import ts from 'typescript';

/**
 * Callback type used for {@link forEachComment}.
 * @category Callbacks
 */
type ForEachCommentCallback = (fullText: string, comment: ts.CommentRange) => void;
/**
 * Iterates over all comments owned by `node` or its children.
 * @category Nodes - Other Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * forEachComment(node, (fullText, comment) => {
 *    console.log(`Found comment at position ${comment.pos}: '${fullText}'.`);
 * });
 * ```
 */
declare function forEachComment(node: ts.Node, callback: ForEachCommentCallback, sourceFile?: ts.SourceFile): void;

/**
 * An option that can be tested with {@link isCompilerOptionEnabled}.
 * @category Compiler Options
 */
type BooleanCompilerOptions = keyof {
    [K in keyof ts.CompilerOptions as NonNullable<ts.CompilerOptions[K]> extends boolean ? K : never]: unknown;
};
/**
 * Checks if a given compiler option is enabled.
 * It handles dependencies of options, e.g. `declaration` is implicitly enabled by `composite` or `strictNullChecks` is enabled by `strict`.
 * However, it does not check dependencies that are already checked and reported as errors, e.g. `checkJs` without `allowJs`.
 * This function only handles boolean flags.
 * @category Compiler Options
 * @example
 * ```ts
 * const options = {
 * 	allowJs: true,
 * };
 *
 * isCompilerOptionEnabled(options, "allowJs"); // true
 * isCompilerOptionEnabled(options, "allowSyntheticDefaultImports"); // false
 * ```
 */
declare function isCompilerOptionEnabled(options: ts.CompilerOptions, option: BooleanCompilerOptions): boolean;
/**
 * An option that can be tested with {@link isStrictCompilerOptionEnabled}.
 * @category Compiler Options
 */
type StrictCompilerOption = "alwaysStrict" | "noImplicitAny" | "noImplicitThis" | "strictBindCallApply" | "strictFunctionTypes" | "strictNullChecks" | "strictPropertyInitialization";
/**
 * Checks if a given compiler option is enabled, accounting for whether all flags
 * (except `strictPropertyInitialization`) have been enabled by `strict: true`.
 * @category Compiler Options
 * @example
 * ```ts
 * const optionsLenient = {
 * 	noImplicitAny: true,
 * };
 *
 * isStrictCompilerOptionEnabled(optionsLenient, "noImplicitAny"); // true
 * isStrictCompilerOptionEnabled(optionsLenient, "noImplicitThis"); // false
 * ```
 * @example
 * ```ts
 * const optionsStrict = {
 * 	noImplicitThis: false,
 * 	strict: true,
 * };
 *
 * isStrictCompilerOptionEnabled(optionsStrict, "noImplicitAny"); // true
 * isStrictCompilerOptionEnabled(optionsStrict, "noImplicitThis"); // false
 * ```
 */
declare function isStrictCompilerOptionEnabled(options: ts.CompilerOptions, option: StrictCompilerOption): boolean;

/**
 * Test if the given node has the given `ModifierFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isModifierFlagSet(node, ts.ModifierFlags.Abstract)) {
 *   // ...
 * }
 * ```
 */
declare function isModifierFlagSet(node: ts.Declaration, flag: ts.ModifierFlags): boolean;
/**
 * Test if the given node has the given `NodeFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNodeFlagSet(node, ts.NodeFlags.AwaitContext)) {
 *   // ...
 * }
 * ```
 */
declare const isNodeFlagSet: (node: ts.Node, flag: ts.NodeFlags) => boolean;
/**
 * Test if the given node has the given `ObjectFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isObjectFlagSet(node, ts.ObjectFlags.Anonymous)) {
 *   // ...
 * }
 * ```
 */
declare function isObjectFlagSet(objectType: ts.ObjectType, flag: ts.ObjectFlags): boolean;
/**
 * Test if the given node has the given `SymbolFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const symbol: ts.Symbol;
 *
 * if (isSymbolFlagSet(symbol, ts.SymbolFlags.Accessor)) {
 *   // ...
 * }
 * ```
 */
declare const isSymbolFlagSet: (symbol: ts.Symbol, flag: ts.SymbolFlags) => boolean;
/**
 * Test if the given symbol's links has the given `CheckFlags` set.
 * @internal
 */
declare function isTransientSymbolLinksFlagSet(links: ts.TransientSymbolLinks, flag: ts.CheckFlags): boolean;
/**
 * Test if the given node has the given `TypeFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const type: ts.Type;
 *
 * if (isTypeFlagSet(type, ts.TypeFlags.Any)) {
 *   // ...
 * }
 * ```
 */
declare const isTypeFlagSet: (type: ts.Type, flag: ts.TypeFlags) => boolean;

/**
 * Test if the given iterable includes a modifier of any of the given kinds.
 * @category Modifier Utilities
 * @example
 * ```ts
 * declare const modifiers: ts.Modifier[];
 *
 * includesModifier(modifiers, ts.SyntaxKind.AbstractKeyword);
 * ```
 */
declare function includesModifier(modifiers: Iterable<ts.ModifierLike> | undefined, ...kinds: ts.ModifierSyntaxKind[]): boolean;

/**
 * What operations(s), if any, an expression applies.
 */
declare enum AccessKind {
    None = 0,
    Read = 1,
    Write = 2,
    Delete = 4,
    ReadWrite = 3
}
/**
 * Determines which operation(s), if any, an expression applies.
 * @example
 * ```ts
 * declare const node: ts.Expression;
 *
 * if (getAccessKind(node).Write & AccessKind.Write) !== 0) {
 *   // this is a reassignment (write)
 * }
 * ```
 */
declare function getAccessKind(node: ts.Expression): AccessKind;

/**
 * An `AssertionExpression` that is declared as const.
 * @category Node Types
 */
type ConstAssertionExpression = {
    type: ts.TypeReferenceNode;
    typeName: ConstAssertionIdentifier;
} & ts.AssertionExpression;
/**
 * An `Identifier` with an `escapedText` value of `"const"`.
 * @category Node Types
 */
type ConstAssertionIdentifier = {
    escapedText: "const" & ts.__String;
} & ts.Identifier;
/**
 * Test if a node is a {@link ConstAssertionExpression}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isConstAssertionExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link ConstAssertionExpression}.
 */
declare function isConstAssertionExpression(node: ts.AssertionExpression): node is ConstAssertionExpression;
/**
 * Test if a node is an `IterationStatement`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isIterationStatement(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `IterationStatement`.
 */
declare function isIterationStatement(node: ts.Node): node is ts.IterationStatement;
/**
 * Test if a node is a `JSDocNamespaceDeclaration`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isJSDocNamespaceDeclaration(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `JSDocNamespaceDeclaration`.
 */
declare function isJSDocNamespaceDeclaration(node: ts.Node): node is ts.JSDocNamespaceDeclaration;
/**
 * Test if a node is a `JsxTagNamePropertyAccess`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isJsxTagNamePropertyAccess(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `JsxTagNamePropertyAccess`.
 */
declare function isJsxTagNamePropertyAccess(node: ts.Node): node is ts.JsxTagNamePropertyAccess;
/**
 * a `NamedDeclaration` that definitely has a name.
 * @category Node Types
 */
interface NamedDeclarationWithName extends ts.NamedDeclaration {
    name: ts.DeclarationName;
}
/**
 * Test if a node is a {@link NamedDeclarationWithName}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNamedDeclarationWithName(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link NamedDeclarationWithName}.
 */
declare function isNamedDeclarationWithName(node: ts.Declaration): node is NamedDeclarationWithName;
/**
 * Test if a node is a `NamespaceDeclaration`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNamespaceDeclaration(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `NamespaceDeclaration`.
 */
declare function isNamespaceDeclaration(node: ts.Node): node is ts.NamespaceDeclaration;
/**
 * A number or string-like literal.
 * @category Node Types
 */
type NumericOrStringLikeLiteral = ts.NumericLiteral | ts.StringLiteralLike;
/**
 * Test if a node is a {@link NumericOrStringLikeLiteral}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNumericOrStringLikeLiteral(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link NumericOrStringLikeLiteral}.
 */
declare function isNumericOrStringLikeLiteral(node: ts.Node): node is NumericOrStringLikeLiteral;
/**
 * Test if a node is a `PropertyAccessEntityNameExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isPropertyAccessEntityNameExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `PropertyAccessEntityNameExpression`.
 */
declare function isPropertyAccessEntityNameExpression(node: ts.Node): node is ts.PropertyAccessEntityNameExpression;
/**
 * Test if a node is a `SuperElementAccessExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSuperElementAccessExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `SuperElementAccessExpression`.
 */
declare function isSuperElementAccessExpression(node: ts.Node): node is ts.SuperElementAccessExpression;
/**
 * Test if a node is a `SuperPropertyAccessExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSuperPropertyAccessExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `SuperPropertyAccessExpression`.
 */
declare function isSuperPropertyAccessExpression(node: ts.Node): node is ts.SuperPropertyAccessExpression;

/**
 * A node that represents the any keyword.
 * @category Node Types
 */
type AnyKeyword = ts.KeywordToken<ts.SyntaxKind.AnyKeyword>;
/**
 * A node that represents the bigint keyword.
 * @category Node Types
 */
type BigIntKeyword = ts.KeywordToken<ts.SyntaxKind.BigIntKeyword>;
/**
 * A node that represents the boolean keyword.
 * @category Node Types
 */
type BooleanKeyword = ts.KeywordToken<ts.SyntaxKind.BooleanKeyword>;
/**
 * A node that represents the false keyword.
 * @category Node Types
 */
type FalseKeyword = ts.KeywordToken<ts.SyntaxKind.FalseKeyword>;
/**
 * A node that represents the import keyword.
 * @category Node Types
 */
type ImportKeyword = ts.KeywordToken<ts.SyntaxKind.ImportKeyword>;
/**
 * A node that represents the never keyword.
 * @category Node Types
 */
type NeverKeyword = ts.KeywordToken<ts.SyntaxKind.NeverKeyword>;
/**
 * A node that represents the null keyword.
 * @category Node Types
 */
type NullKeyword = ts.KeywordToken<ts.SyntaxKind.NullKeyword>;
/**
 * A node that represents the number keyword.
 * @category Node Types
 */
type NumberKeyword = ts.KeywordToken<ts.SyntaxKind.NumberKeyword>;
/**
 * A node that represents the object keyword.
 * @category Node Types
 */
type ObjectKeyword = ts.KeywordToken<ts.SyntaxKind.ObjectKeyword>;
/**
 * A node that represents the string keyword.
 * @category Node Types
 */
type StringKeyword = ts.KeywordToken<ts.SyntaxKind.StringKeyword>;
/**
 * A node that represents the super keyword.
 * @category Node Types
 */
type SuperKeyword = ts.KeywordToken<ts.SyntaxKind.SuperKeyword>;
/**
 * A node that represents the symbol keyword.
 * @category Node Types
 */
type SymbolKeyword = ts.KeywordToken<ts.SyntaxKind.SymbolKeyword>;
/**
 * A node that represents the this keyword.
 * @category Node Types
 */
type ThisKeyword = ts.KeywordToken<ts.SyntaxKind.ThisKeyword>;
/**
 * A node that represents the true keyword.
 * @category Node Types
 */
type TrueKeyword = ts.KeywordToken<ts.SyntaxKind.TrueKeyword>;
/**
 * A node that represents the undefined keyword.
 * @category Node Types
 */
type UndefinedKeyword = ts.KeywordToken<ts.SyntaxKind.UndefinedKeyword>;
/**
 * A node that represents the unknown keyword.
 * @category Node Types
 */
type UnknownKeyword = ts.KeywordToken<ts.SyntaxKind.UnknownKeyword>;
/**
 * A node that represents the void keyword.
 * @category Node Types
 */
type VoidKeyword = ts.KeywordToken<ts.SyntaxKind.VoidKeyword>;
/**
 * Test if a node is an `AbstractKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAbstractKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AbstractKeyword`.
 */
declare function isAbstractKeyword(node: ts.Node): node is ts.AbstractKeyword;
/**
 * Test if a node is an `AccessorKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAccessorKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AccessorKeyword`.
 */
declare function isAccessorKeyword(node: ts.Node): node is ts.AccessorKeyword;
/**
 * Test if a node is an {@link AnyKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAnyKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an {@link AnyKeyword}.
 */
declare function isAnyKeyword(node: ts.Node): node is AnyKeyword;
/**
 * Test if a node is an `AssertKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAssertKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AssertKeyword`.
 */
declare function isAssertKeyword(node: ts.Node): node is ts.AssertKeyword;
/**
 * Test if a node is an `AssertsKeyword`.
 * @deprecated With TypeScript v5, in favor of typescript's `isAssertsKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAssertsKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AssertsKeyword`.
 */
declare function isAssertsKeyword(node: ts.Node): node is ts.AssertsKeyword;
/**
 * Test if a node is an `AsyncKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAsyncKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AsyncKeyword`.
 */
declare function isAsyncKeyword(node: ts.Node): node is ts.AsyncKeyword;
/**
 * Test if a node is an `AwaitKeyword`.
 * @deprecated With TypeScript v5, in favor of typescript's `isAwaitKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAwaitKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AwaitKeyword`.
 */
declare function isAwaitKeyword(node: ts.Node): node is ts.AwaitKeyword;
/**
 * Test if a node is a {@link BigIntKeyword}.
 * @deprecated With TypeScript v5, in favor of typescript's `isBigIntKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isBigIntKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link BigIntKeyword}.
 */
declare function isBigIntKeyword(node: ts.Node): node is BigIntKeyword;
/**
 * Test if a node is a {@link BooleanKeyword}.
 * @deprecated With TypeScript v5, in favor of typescript's `isBooleanKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isBooleanKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link BooleanKeyword}.
 */
declare function isBooleanKeyword(node: ts.Node): node is BooleanKeyword;
/**
 * Test if a node is a `ColonToken`.
 * @deprecated With TypeScript v5, in favor of typescript's `isColonToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isColonToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `ColonToken`.
 */
declare function isColonToken(node: ts.Node): node is ts.ColonToken;
/**
 * Test if a node is a `ConstKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isConstKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `ConstKeyword`.
 */
declare function isConstKeyword(node: ts.Node): node is ts.ConstKeyword;
/**
 * Test if a node is a `DeclareKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isDeclareKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `DeclareKeyword`.
 */
declare function isDeclareKeyword(node: ts.Node): node is ts.DeclareKeyword;
/**
 * Test if a node is a `DefaultKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isDefaultKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `DefaultKeyword`.
 */
declare function isDefaultKeyword(node: ts.Node): node is ts.DefaultKeyword;
/**
 * Test if a node is a `DotToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isDotToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `DotToken`.
 */
declare function isDotToken(node: ts.Node): node is ts.DotToken;
/**
 * Test if a node is an `EndOfFileToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isEndOfFileToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `EndOfFileToken`.
 */
declare function isEndOfFileToken(node: ts.Node): node is ts.EndOfFileToken;
/**
 * Test if a node is an `EqualsGreaterThanToken`.
 * @deprecated With TypeScript v5, in favor of typescript's `isEqualsGreaterThanToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isEqualsGreaterThanToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `EqualsGreaterThanToken`.
 */
declare function isEqualsGreaterThanToken(node: ts.Node): node is ts.EqualsGreaterThanToken;
/**
 * Test if a node is an `EqualsToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isEqualsToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `EqualsToken`.
 */
declare function isEqualsToken(node: ts.Node): node is ts.EqualsToken;
/**
 * Test if a node is an `ExclamationToken`.
 * @deprecated With TypeScript v5, in favor of typescript's `isExclamationToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isExclamationToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `ExclamationToken`.
 */
declare function isExclamationToken(node: ts.Node): node is ts.ExclamationToken;
/**
 * Test if a node is an `ExportKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isExportKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `ExportKeyword`.
 */
declare function isExportKeyword(node: ts.Node): node is ts.ExportKeyword;
/**
 * Test if a node is a {@link FalseKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isFalseKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link FalseKeyword}.
 */
declare function isFalseKeyword(node: ts.Node): node is FalseKeyword;
/**
 * Test if a node is a `FalseLiteral`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isFalseLiteral(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `FalseLiteral`.
 */
declare function isFalseLiteral(node: ts.Node): node is ts.FalseLiteral;
/**
 * Test if a node is an `ImportExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isImportExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `ImportExpression`.
 */
declare function isImportExpression(node: ts.Node): node is ts.ImportExpression;
/**
 * Test if a node is an {@link ImportKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isImportKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an {@link ImportKeyword}.
 */
declare function isImportKeyword(node: ts.Node): node is ImportKeyword;
/**
 * Test if a node is an `InKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isInKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `InKeyword`.
 */
declare function isInKeyword(node: ts.Node): node is ts.InKeyword;
/**
 * Test if a node is an `InputFiles`.
 * @deprecated With TypeScript v5
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isInputFiles(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `InputFiles`.
 */
declare function isInputFiles(node: ts.Node): node is ts.InputFiles;
/**
 * Test if a node is a `JSDocText`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isJSDocText(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `JSDocText`.
 */
declare function isJSDocText(node: ts.Node): node is ts.JSDocText;
/**
 * Test if a node is a `JsonMinusNumericLiteral`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isJsonMinusNumericLiteral(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `JsonMinusNumericLiteral`.
 */
declare function isJsonMinusNumericLiteral(node: ts.Node): node is ts.JsonMinusNumericLiteral;
/**
 * Test if a node is a {@link NeverKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNeverKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link NeverKeyword}.
 */
declare function isNeverKeyword(node: ts.Node): node is NeverKeyword;
/**
 * Test if a node is a {@link NullKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNullKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link NullKeyword}.
 */
declare function isNullKeyword(node: ts.Node): node is NullKeyword;
/**
 * Test if a node is a `NullLiteral`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNullLiteral(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `NullLiteral`.
 */
declare function isNullLiteral(node: ts.Node): node is ts.NullLiteral;
/**
 * Test if a node is a {@link NumberKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNumberKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link NumberKeyword}.
 */
declare function isNumberKeyword(node: ts.Node): node is NumberKeyword;
/**
 * Test if a node is an {@link ObjectKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isObjectKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an {@link ObjectKeyword}.
 */
declare function isObjectKeyword(node: ts.Node): node is ObjectKeyword;
/**
 * Test if a node is an `OutKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isOutKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `OutKeyword`.
 */
declare function isOutKeyword(node: ts.Node): node is ts.OutKeyword;
/**
 * Test if a node is an `OverrideKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isOverrideKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `OverrideKeyword`.
 */
declare function isOverrideKeyword(node: ts.Node): node is ts.OverrideKeyword;
/**
 * Test if a node is a `PrivateKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isPrivateKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `PrivateKeyword`.
 */
declare function isPrivateKeyword(node: ts.Node): node is ts.PrivateKeyword;
/**
 * Test if a node is a `ProtectedKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isProtectedKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `ProtectedKeyword`.
 */
declare function isProtectedKeyword(node: ts.Node): node is ts.ProtectedKeyword;
/**
 * Test if a node is a `PublicKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isPublicKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `PublicKeyword`.
 */
declare function isPublicKeyword(node: ts.Node): node is ts.PublicKeyword;
/**
 * Test if a node is a `QuestionDotToken`.
 * @deprecated With TypeScript v5, in favor of typescript's `isQuestionDotToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isQuestionDotToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `QuestionDotToken`.
 */
declare function isQuestionDotToken(node: ts.Node): node is ts.QuestionDotToken;
/**
 * Test if a node is a `QuestionToken`.
 * @deprecated With TypeScript v5, in favor of typescript's `isQuestionToken`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isQuestionToken(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `QuestionToken`.
 */
declare function isQuestionToken(node: ts.Node): node is ts.QuestionToken;
/**
 * Test if a node is a `ReadonlyKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isReadonlyKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `ReadonlyKeyword`.
 */
declare function isReadonlyKeyword(node: ts.Node): node is ts.ReadonlyKeyword;
/**
 * Test if a node is a `StaticKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isStaticKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `StaticKeyword`.
 */
declare function isStaticKeyword(node: ts.Node): node is ts.StaticKeyword;
/**
 * Test if a node is a {@link StringKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isStringKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link StringKeyword}.
 */
declare function isStringKeyword(node: ts.Node): node is StringKeyword;
/**
 * Test if a node is a `SuperExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSuperExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `SuperExpression`.
 */
declare function isSuperExpression(node: ts.Node): node is ts.SuperExpression;
/**
 * Test if a node is a {@link SuperKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSuperKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link SuperKeyword}.
 */
declare function isSuperKeyword(node: ts.Node): node is SuperKeyword;
/**
 * Test if a node is a {@link SymbolKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSymbolKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link SymbolKeyword}.
 */
declare function isSymbolKeyword(node: ts.Node): node is SymbolKeyword;
/**
 * Test if a node is a `SyntaxList`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSyntaxList(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `SyntaxList`.
 */
declare function isSyntaxList(node: ts.Node): node is ts.SyntaxList;
/**
 * Test if a node is a `ThisExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isThisExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `ThisExpression`.
 */
declare function isThisExpression(node: ts.Node): node is ts.ThisExpression;
/**
 * Test if a node is a {@link ThisKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isThisKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link ThisKeyword}.
 */
declare function isThisKeyword(node: ts.Node): node is ThisKeyword;
/**
 * Test if a node is a {@link TrueKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isTrueKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link TrueKeyword}.
 */
declare function isTrueKeyword(node: ts.Node): node is TrueKeyword;
/**
 * Test if a node is a `TrueLiteral`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isTrueLiteral(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `TrueLiteral`.
 */
declare function isTrueLiteral(node: ts.Node): node is ts.TrueLiteral;
/**
 * Test if a node is an {@link UndefinedKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isUndefinedKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an {@link UndefinedKeyword}.
 */
declare function isUndefinedKeyword(node: ts.Node): node is UndefinedKeyword;
/**
 * Test if a node is an {@link UnknownKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isUnknownKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an {@link UnknownKeyword}.
 */
declare function isUnknownKeyword(node: ts.Node): node is UnknownKeyword;
/**
 * Test if a node is an `UnparsedPrologue`.
 * @deprecated With TypeScript v5
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isUnparsedPrologue